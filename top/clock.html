<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>アナログ時計</title>
  
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      background-color: transparent;
      overflow: hidden;
    }
    
    .clock-container {
      width: 100%;
      max-width: 250px;
      margin: 0 auto;
      background: transparent;
    }
    
    .number {
      fill: #000000;
      font-size: 8px;
      font-family: "Arial", serif;
      font-style: normal;
      font-weight: normal;
    }
    
    .date {
      fill: #000000;
      font-size: 5.9px;
      font-family: "Georgia", serif;
      text-anchor: middle;
      dominant-baseline: central;
    }
    
    .day {
      fill: #ffffff;
      font-size: 5px;
      font-family: "Georgia", serif;
      text-anchor: middle;
      dominant-baseline: central;
    }
    
    .logo {
      fill: #000000;
      font-size: 20px;
      font-family: "Arial", serif;
      text-anchor: middle;
      dominant-baseline: central;
      font-style: normal;
      font-weight: normal;
    }
    
    .center-dot {
      fill: #ff4015;
    }
    
    .tick {
      stroke: #000000;
    }
    
    .clock-face {
      fill: url(#faceGradient);
      stroke: url(#borderGradient);
      stroke-width: 5;
    }
    
    .inner-border {
      fill: none;
      stroke: url(#innerBorderGradient);
      stroke-width: 0;
    }

    .weather-icon, .weather-temp, .weather-desc, .weather-humidity {
      fill: #000000;
      font-family: "Arial", sans-serif;
      text-anchor: middle;
      dominant-baseline: central;
    }

    .date-background {
      fill: url(#dateBackgroundGradient);
    }

    .day-background {
      fill: url(#dayBackgroundGradient);
    }
  </style>
</head>
<body>
  <div class="clock-container">
    <svg id="clock" width="100%" height="100%" viewBox="0 0 100 100">
      <defs>
        <linearGradient id="faceGradient" x1="0%" y1="0%" x2="0%" y2="0%">
        <stop offset="0%" stop-color="#ffffff" />
        <stop offset="100%" stop-color="#ffffff" />
      </linearGradient>
        <linearGradient id="borderGradient" x1="0%" y1="0%" x2="0%" y2="0%">
        <stop offset="0%" stop-color="#00a1d8" />
        <stop offset="100%" stop-color="#00a1d8" />
      </linearGradient>
        <linearGradient id="innerBorderGradient" x1="0%" y1="0%" x2="0%" y2="0%">
        <stop offset="0%" stop-color="#cccccc" />
        <stop offset="100%" stop-color="#cccccc" />
      </linearGradient>
        <linearGradient id="dateBackgroundGradient" x1="0%" y1="0%" x2="0%" y2="0%">
        <stop offset="0%" stop-color="#f0f0f0" />
        <stop offset="100%" stop-color="#f0f0f0" />
      </linearGradient>
        <linearGradient id="dayBackgroundGradient" x1="0%" y1="0%" x2="0%" y2="0%">
        <stop offset="0%" stop-color="#ff4015" />
        <stop offset="100%" stop-color="#ff4015" />
      </linearGradient>
      </defs>
      <circle class="clock-face" cx="50" cy="50" r="45" />
      <circle class="inner-border" cx="50" cy="50" r="42.5" />
      <g id="ticks"></g>
      
      <g id="date">
        
        <text id="date-text" class="date" x="50" y="74"></text>
      </g>
      <g id="day">
        <rect class="day-background" x="43.5" y="61.5" width="13" height="9" rx="3" ry="3" />
        <text id="day-text" class="day" x="50" y="66"></text>
      </g>
      <text class="logo" x="50" y="40">👀</text>
      
      <g id="hour"></g>
      <g id="minute"></g>
      <g id="second"></g>
      <circle class="center-dot" cx="50" cy="50" r="4.5" />
    </svg>
  </div>

  <script>
    const settings = {"faceColor":"#ffffff","borderColor":"#00a1d8","borderWidth":"5","numberColor":"#000000","hourHandColor":"#000000","minuteHandColor":"#000000","secondHandColor":"#d6d6d6","dateColor":"#000000","dayColor":"#ffffff","dateFont":"Georgia","dateFontSize":"5.9","dayFont":"Georgia","dayFontSize":"5","dateBackgroundColor":"#f0f0f0","dayBackgroundColor":"#ff4015","size":"250","fontSize":"8","showDate":true,"showDay":true,"showTicks":true,"tickColor":"#000000","majorTickLength":"7","minorTickLength":"2","majorTickWidth":"0.5","smoothSecond":true,"logo":"👀","logoSize":"20","logoPosition":"40","font":"Arial","logoFont":"Arial","logoColor":"#000000","centerDotColor":"#ff4015","centerDotSize":4.5,"hourHandShape":"baton","minuteHandShape":"baton","secondHandShape":"line","hourHandLength":"27","hourHandWidth":"1.5","minuteHandLength":"35","minuteHandWidth":"1","secondHandLength":"40","secondHandWidth":"0.5","showNumbers":false,"showLogo":true,"numberPosition":"32","dateBackgroundWidth":"16","dateBackgroundHeight":"9","dayBackgroundWidth":"13","dayBackgroundHeight":"9","datePositionX":"50","datePositionY":"74","dayPositionX":50,"dayPositionY":"66","tickPosition":"40.5","faceMaterial":"flat","borderMaterial":"flat","hourHandTailLength":"0","minuteHandTailLength":"0","secondHandTailLength":"10","showDateBackground":false,"showDayBackground":true,"innerBorderColor":"#cccccc","innerBorderWidth":"0","innerBorderPosition":"42.5","innerBorderMaterial":"flat","showInnerBorder":true,"timezone":"GMT+9","numberPattern":"roman","numberOrientation":"upright","numberItalic":false,"numberBold":false,"debugFixedHands":false,"debugHideOtherHands":false,"debugShowCrosshair":false,"debugHideCenterDot":false,"debugTargetHand":"hour","hourHandPivotOffsetY":0,"minuteHandPivotOffsetY":0,"secondHandPivotOffsetY":0,"weather":{"enabled":false,"city":"","color":"#000000","fontFamily":"Arial","fontSize":4,"position":{"x":50,"y":80},"showIcon":true,"showTemperature":true,"showDescription":true,"showHumidity":true,"updateInterval":60,"spacing":6},"dateBackgroundCornerRadius":3,"dayBackgroundCornerRadius":3,"logoItalic":false,"logoBold":false};
    let weatherData = null;
    
    function safeNumber(value, defaultValue = 0) {
      const num = Number(value);
      return isNaN(num) ? defaultValue : num;
    }
    
    function hexToHSL(hex) {
      const r = parseInt(hex.slice(1, 3), 16) / 255;
      const g = parseInt(hex.slice(3, 5), 16) / 255;
      const b = parseInt(hex.slice(5, 7), 16) / 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h = 0, s = 0;
      const l = (max + min) / 2;
      if (max !== min) {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }
      return [h * 360, s * 100, l * 100];
    }

    function hslToHex(h, s, l) {
      l /= 100;
      const a = (s * Math.min(l, 1 - l)) / 100;
      const f = (n) => {
        const k = (n + h / 30) % 12;
        const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return Math.round(255 * color).toString(16).padStart(2, "0");
      };
      return `#${f(0)}${f(8)}${f(4)}`;
    }

    function getTimezoneOffset(timezone) {
      if (timezone === "local") return -new Date().getTimezoneOffset();
      if (timezone === "UTC") return 0;
      const match = timezone.match(/GMT([+-])(\d+)/);
      return match ? (match[1] === "+" ? 1 : -1) * parseInt(match[2], 10) * 60 : 0;
    }

    function getWeatherInfo(weatherCode) {
      const weatherMap = {
        0: { description: "快晴", icon: "☀️" }, 1: { description: "晴れ", icon: "🌤️" }, 2: { description: "一部曇り", icon: "⛅" }, 3: { description: "曇り", icon: "☁️" }, 45: { description: "霧", icon: "🌫️" }, 48: { description: "霧氷", icon: "🌫️" }, 51: { description: "小雨", icon: "🌦️" }, 53: { description: "雨", icon: "🌧️" }, 55: { description: "大雨", icon: "🌧️" }, 61: { description: "小雨", icon: "🌦️" }, 63: { description: "雨", icon: "🌧️" }, 65: { description: "大雨", icon: "🌧️" }, 71: { description: "小雪", icon: "🌨️" }, 73: { description: "雪", icon: "❄️" }, 75: { description: "大雪", icon: "❄️" }, 80: { description: "にわか雨", icon: "🌦️" }, 81: { description: "雨", icon: "🌧️" }, 85: { description: "にわか雪", icon: "🌨️" }, 86: { description: "大雪", icon: "❄️" }, 95: { description: "雷雨", icon: "⛈️" }, 96: { description: "雷雨（雹）", icon: "⛈️" }, 99: { description: "激しい雷雨", icon: "⛈️" }
      };
      return weatherMap[weatherCode] || { description: "不明", icon: "❓" };
    }

    async function fetchWeatherData() {
      if (!settings.weather.enabled || !settings.weather.city) return null;
      try {
        const geoResponse = await fetch(`https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(settings.weather.city)}&format=json&limit=1&accept-language=ja,en`, { headers: { 'User-Agent': 'AnalogClock/1.0' } });
        if (!geoResponse.ok) throw new Error(`地理情報API エラー: ${geoResponse.status}`);
        const geoData = await geoResponse.json();
        if (!geoData || geoData.length === 0) { console.error('都市が見つかりません:', settings.weather.city); return null; }
        const lat = parseFloat(geoData[0].lat);
        const lon = parseFloat(geoData[0].lon);
        const weatherResponse = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true&hourly=relative_humidity_2m&timezone=auto`);
        if (!weatherResponse.ok) throw new Error(`天気API エラー: ${weatherResponse.status}`);
        const data = await weatherResponse.json();
        if (!data || !data.current_weather) { console.error('天気データが無効'); return null; }
        const weatherInfo = getWeatherInfo(data.current_weather.weathercode);
        let humidityValue = undefined;
        if (data.hourly && data.hourly.time && data.hourly.relative_humidity_2m) {
          const currentTime = new Date(data.current_weather.time);
          const hourlyTimes = data.hourly.time.map(t => new Date(t));
          const hourlyHumidities = data.hourly.relative_humidity_2m;
          let closestIndex = -1; let minDiff = Number.POSITIVE_INFINITY;
          for (let i = 0; i < hourlyTimes.length; i++) { const diff = Math.abs(currentTime.getTime() - hourlyTimes[i].getTime()); if (diff < minDiff) { minDiff = diff; closestIndex = i; } }
          if (closestIndex !== -1) humidityValue = hourlyHumidities[closestIndex];
        }
        return { temperature: Number.parseFloat(data.current_weather.temperature.toFixed(1)), icon: weatherInfo.icon, description: weatherInfo.description, humidity: humidityValue !== undefined ? humidityValue : 0 };
      } catch (error) { console.error('天気データ取得エラー:', error); return null; }
    }

    function updateWeatherDisplay() {
      const weatherGroup = document.getElementById('weather');
      if (!weatherGroup || !weatherData) return;
      const wc = settings.weather; // Shorthand for weather config
      const elements = [];
      if (wc.showIcon) elements.push({ type: 'icon', content: weatherData.icon, fontSize: wc.fontSize * 1.2 });
      if (wc.showDescription) elements.push({ type: 'desc', content: weatherData.description, fontSize: wc.fontSize * 0.8 });
      if (wc.showTemperature) elements.push({ type: 'temp', content: `${weatherData.temperature}°C`, fontSize: wc.fontSize });
      if (wc.showHumidity && weatherData.humidity != null) elements.push({ type: 'humidity', content: `${weatherData.humidity}%`, fontSize: wc.fontSize * 0.8 });
      if (elements.length === 0) { weatherGroup.innerHTML = ''; return; }
      const totalHeight = (elements.length - 1) * wc.spacing;
      const startY = wc.position.y - totalHeight / 2;
      let html = '';
      elements.forEach((el, i) => {
        const y = startY + i * wc.spacing;
        html += `<text class="weather-${el.type}" x="${wc.position.x}" y="${y}" style="font-size: ${el.fontSize}px;">${el.content}</text>`;
      });
      weatherGroup.innerHTML = html;
    }

    // 針の描画関数
    function drawHand(handType, degrees, length, width, color, shape, tailLength = 0, pivotOffsetY = 0) {
      let adjustedPivotOffsetY = pivotOffsetY;
      if (shape === "baroque") {
        adjustedPivotOffsetY += -1.1; // バロック形状に固有のオフセットを加算
      }
      const effectiveDegrees = degrees; // デバッグ関連の条件を削除
      // settings.handCenterOffsetX と settings.handCenterOffsetY を使用
      const centerX = 50 + safeNumber(settings.handCenterOffsetX, 0);
      const centerY = 50 + safeNumber(settings.handCenterOffsetY, 0);
      const transform = `translate(${centerX}, ${centerY}) rotate(${effectiveDegrees}) translate(0, ${-adjustedPivotOffsetY})`;
      
      let handSvgString = "";
      // (0,0) を回転軸の根本として描画
      switch (shape) {
        case "line":
          handSvgString = `<line x1="0" y1="${tailLength}" x2="0" y2="${-length}" stroke="${color}" stroke-width="${width}" stroke-linecap="round"/>`;
          break;
        case "line-square":
          handSvgString = `<line x1="0" y1="${tailLength}" x2="0" y2="${-length}" stroke="${color}" stroke-width="${width}" stroke-linecap="butt"/>`;
          break;
        case "arrow":
          const headL = length * 0.25, stemW = width * 0.6, headW = width * 0.3, arrowW = width, actualTailL = tailLength;
          const arrowH = `M0,${-length} L${-arrowW/2},${-length+headL} H${-headW/2} V0 H${headW/2} V${-length+headL} H${arrowW/2} Z`;
          const stemP = `M${-headW/2},${-length+headL} Q${-stemW/2},${-length/2} ${-stemW/2},0 L${stemW/2},0 Q${stemW/2},${-length/2} ${headW/2},${-length+headL} Z`;
          const tailP = actualTailL > 0 ? `M${-stemW/2},0 Q${-stemW/2},${actualTailL/2} ${-headW/2},${actualTailL} L${headW/2},${actualTailL} Q${stemW/2},${actualTailL/2} ${stemW/2},0 Z` : "";
          handSvgString = `<path d="${arrowH}" fill="${color}" /><path d="${stemP}" fill="${color}" />${tailP ? `<path d="${tailP}" fill="${color}" />` : ""}`;
          break;
        case "diamond":
          const dW = width*2, dM = length*0.33, tipY_d = -length, tailY_d = tailLength, midY_d = -dM, lX_d = -dW/2, rX_d = dW/2;
          handSvgString = `<path d="M0,${tailY_d} L${lX_d},${midY_d} L0,${tipY_d} L${rX_d},${midY_d} Z" fill="${color}"/>`;
          break;
        case "breguet":
          const bHL = length*0.25, bSW = width*0.6, bHW = width*0.3, bAW = width*0.9, bCS = width*0.8, bCStr = width*0.24, bATL = tailLength;
          const bArrowHead = `M0,${-length} L${-bAW/2},${-length+bHL} H${bAW/2} Z`;
          const bCircleCenterY = -length + bHL + bCS * 2 - bCS;
          const bCircle = `<circle cx="0" cy="${bCircleCenterY}" r="${bCS}" fill="none" stroke="${color}" stroke-width="${bCStr}" />`;
          const bStem = `M${-bHW/2},${-length+bHL+bCS*2} Q${-bSW/2},${-length/2} ${-bSW/2},0 L${bSW/2},0 Q${bSW/2},${-length/2} ${bHW/2},${-length+bHL+bCS*2} Z`;
          const bTail = bATL > 0 ? `M${-bSW/2},0 Q${-bSW/2},${bATL/2} ${-bHW/2},${bATL} L${bHW/2},${bATL} Q${bSW/2},${bATL/2} ${bSW/2},0 Z` : "";
          handSvgString = `<path d="${bArrowHead}" fill="${color}" />${bCircle}<path d="${bStem}" fill="${color}" />${bTail ? `<path d="${bTail}" fill="${color}" />` : ""}`;
          break;
        case "losange":
          const losW = width * 2, losM = length * 0.5, tipY_los = -length, tailY_los = tailLength, midY_los = -losM, p1X_los = -losW/2, p2X_los = losW/2;
          handSvgString = `<path d="M0,${tailY_los} L${p1X_los},${midY_los} L0,${tipY_los} L${p2X_los},${midY_los} Z" fill="${color}"/>`;
          break;
        case "baton":
          const batW = width, tipY_bat = -length, tailY_bat = tailLength, halfW_bat = batW/2;
          handSvgString = `<path d="M${-halfW_bat},${tailY_bat} L${-halfW_bat},${tipY_bat} L${halfW_bat},${tipY_bat} L${halfW_bat},${tailY_bat} Z" fill="${color}"/>`;
          break;
        case "leaf":
          const leafW = width * 2.5, leafL = length * 0.9, tipY_leaf = -leafL, tailY_leaf = tailLength;
          const leafP = `M0,${tipY_leaf} C${-leafW/2},${tipY_leaf*0.7} ${-leafW/3},${tipY_leaf*0.3} ${-width/2},0 L${width/2},0 C${leafW/3},${tipY_leaf*0.3} ${leafW/2},${tipY_leaf*0.7} 0,${tipY_leaf} Z`;
          const leafTP = tailLength > 0 ? `<path d="M${-width/2},0 L${-width},${tailY_leaf} L${width},${tailY_leaf} L${width/2},0 Z" fill="${color}" />` : "";
          handSvgString = `<path d="${leafP}" fill="${color}" />${leafTP}`;
          break;
        case "spade":
          const spdW = width*2, spdL = length*0.9, spdSW = width*0.6, spdATL = tailLength, tipY_spd = -spdL, tailY_spd = spdATL;
          const spdH = `M0,${tipY_spd} C${-spdW/2},${tipY_spd*0.7} ${-spdW},${tipY_spd*0.5} ${-spdW*0.8},${tipY_spd*0.3} C${-spdW*0.6},${tipY_spd*0.1} ${-spdSW/2},${tipY_spd*0.1} ${-spdSW/2},0 L${spdSW/2},0 C${spdSW/2},${tipY_spd*0.1} ${spdW*0.6},${tipY_spd*0.1} ${spdW*0.8},${tipY_spd*0.3} C${spdW},${tipY_spd*0.5} ${spdW/2},${tipY_spd*0.7} 0,${tipY_spd} Z`;
          const spdTP = spdATL > 0 ? `<path d="M${-spdSW/2},0 Q${-spdSW/2},${tailY_spd/2} ${-spdSW},${tailY_spd} L${spdSW},${tailY_spd} Q${spdSW/2},${tailY_spd/2} ${spdSW/2},0 Z" fill="${color}" />` : "";
          handSvgString = `<path d="${spdH}" fill="${color}" />${spdTP}`;
          break;
        case "rectangle":
          const rectHW = width/2, tipY_rect = -length, tailY_rect = tailLength;
          handSvgString = `<polygon points="${-rectHW},${tipY_rect} ${rectHW},${tipY_rect} ${rectHW},${tailY_rect} ${-rectHW},${tailY_rect}" fill="${color}"/>`;
          break;
        case "trapezium":
          const wideW = 1.5 * width, narrowW = 0.9 * width, tipY_trap = -length, tailY_trap = tailLength;
          handSvgString = `<path d="M${-width/2},${tailY_trap} L${-wideW/2},0 L${-narrowW/2},${tipY_trap} L${narrowW/2},${tipY_trap} L${wideW/2},0 L${width/2},${tailY_trap} Z" fill="${color}"/>`;
          break;
      case "pentagon":
        const baseHalfWidth_pent = width / 2; // 根本の半分の幅
        const shoulderHalfWidth_pent = width / 2; // 肩の半分の幅 (根本と同じにする)
        const subL_pent = length * 0.9; // 肩の点までの長さ
        const tipY_pent = -length;
        const tailY_pent = tailLength;
        const shoulderY_pent = -subL_pent;
        handSvgString = `<path d="M${-baseHalfWidth_pent},${tailY_pent} L${-shoulderHalfWidth_pent},${shoulderY_pent} L0,${tipY_pent} L${shoulderHalfWidth_pent},${shoulderY_pent} L${baseHalfWidth_pent},${tailY_pent} Z" fill="${color}"/>`;
        break;
        case "triangle":
          const triW = width * 2, tipY_tri = -length, tailY_tri = tailLength;
          const triP = `M${-triW/2},0 L0,${tipY_tri} L${triW/2},0 Z`;
          const triTP = tailLength > 0 ? `<path d="M${-triW/2},0 L${-width},${tailY_tri} L${width},${tailY_tri} L${triW/2},0 Z" fill="${color}" />` : "";
          handSvgString = `<path d="${triP}" fill="${color}" />${triTP}`;
          break;
        case "lance":
          const svgCenterX_lance = 826.22;
          const originalPathLength_lance = 1007.24 - 571.53;
          const scaleY_lance = length / originalPathLength_lance;
          const scaleX_lance = Math.max(0.01, width / 100);
          // ユーザーが指定した「根本の丸い部分が中心になるように調整」するためのオフセット
          const adjustedCenterOffsetY_lance = 994.33;
          handSvgString = `<g transform="scale(${scaleX_lance}, ${scaleY_lance}) translate(${-svgCenterX_lance}, ${-adjustedCenterOffsetY_lance})">
            <path d="m 826.22,1007.24 c -7.13,0 -12.91,-5.78 -12.91,-12.91 0,-7.13 5.78,-12.91 12.91,-12.91 7.13,0 12.91,5.78 12.91,12.91 0,7.13 -5.78,12.91 -12.91,12.91 z m 7.8,-41.13 c 0.64,-12.7 11.46,-19.35 11.46,-19.35 v -9.63 h -11.24 c 12.04,-15.25 9.63,-52.98 3.21,-75.46 -6.42,-22.48 -4.01,-65.02 -4.01,-65.02 0,0 16.86,-3.21 11.24,-7.22 -12.04,-8.83 -10.43,-39.33 -10.43,-39.33 h 14.45 v -10.44 h -14.45 c 8.03,-21.67 2.41,-61.01 0,-71.44 -2.41,-10.43 0,-58.6 0,-75.45 0,-16.86 -8.03,-20.87 -8.03,-20.87 v 0 c 0,0 -8.03,4.01 -8.03,20.87 0,16.86 2.41,65.02 0,75.45 -2.41,-10.44 -8.03,49.77 0,71.44 h -14.45 v 10.44 h 14.45 c 0,0 1.61,30.5 -10.44,39.33 -5.62,4.01 11.24,7.22 11.24,7.22 0,0 2.41,42.54 -4.01,65.02 -6.42,22.48 -8.83,60.2 3.21,75.46 h -11.24 v 9.63 c 0,0 10.82,6.64 11.46,19.35 -12.39,3.42 -21.49,14.74 -21.49,28.22 0,16.18 13.12,29.3 29.3,29.3 16.18,0 29.3,-13.12 29.3,-29.3 0,-13.47 -9.11,-24.8 -21.5,-28.22" fill="${color}" />
          </g>`;
          break;
        case "baroque":
          const svgCenterX_baroque = 897.69;
          const svgHandStart_baroque = 405.53 + 14.41;
          const svgHandEnd_baroque = 861.03;
          const originalPathLength_baroque = svgHandEnd_baroque - svgHandStart_baroque;
          const scaleY_baroque = length / originalPathLength_baroque;
          const scaleX_baroque = Math.max(0.01, width / 100);
          const adjustedCenterOffsetY_baroque = svgHandEnd_baroque;
          handSvgString = `<g transform="scale(${scaleX_baroque}, ${scaleY_baroque}) translate(${-svgCenterX_baroque}, ${-adjustedCenterOffsetY_baroque})">
            <path d="m 918.89,594.96 c 0,0 -9.71,-11.31 -21.2,-11.08 -11.48,-0.23 -21.2,11.08 -21.2,11.08 -21.2,-26.49 0,-35.32 0,-35.32 0.21,-17.92 13.67,-22.5 21.2,-23.67 7.53,1.17 20.99,5.75 21.2,23.67 0,0 21.2,8.83 0,35.32 z m -21.2,266.07 c -7.96,0 -14.41,-6.45 -14.41,-14.41 0,-7.96 6.45,-14.41 14.41,-14.41 7.96,0 14.41,6.45 14.41,14.41 0,7.96 -6.45,14.41 -14.41,14.41 z m 29.52,-305.4 c 1.61,-20.87 -14.44,-24.88 -20.07,-28.9 -5.61,-4.01 0,-109.97 0,-121.21 0,-11.24 -9.45,-12.04 -9.45,-12.04 0,0 -9.45,0.8 -9.45,12.04 0,11.24 5.63,117.2 0,121.21 -5.61,4.01 -21.67,8.03 -20.07,28.9 0,0 -13.64,8.03 -12.84,16.86 0.8,8.83 13.64,24.89 13.64,24.89 l -9.63,3.21 c 0,0 17.65,6.42 20.87,19.27 2.97,11.86 10.55,151.1 -0.57,199.49 -8.83,5.86 -14.65,15.88 -14.65,27.28 0,18.07 14.64,32.71 32.71,32.71 18.07,0 32.72,-14.65 32.72,-32.71 0,-11.39 -5.83,-21.42 -14.67,-27.28 -11.11,-48.39 -3.53,-187.63 -0.57,-199.49 3.21,-12.84 20.88,-19.27 20.88,-19.27 l -9.64,-3.21 c 0,0 12.85,-16.05 13.65,-24.89 0.8,-8.83 -12.85,-16.86 -12.85,-16.86 z" fill="${color}" />
          </g>`;
          break;
        case "fleurdelis":
          const svgCenterX_fleur = 225.88;
          const svgHandStart_fleur = 506.08;
          const svgHandEnd_fleur = 967.98;
          const originalPathLength_fleur = svgHandEnd_fleur - svgHandStart_fleur;
          const scaleY_fleur = length / originalPathLength_fleur;
          const scaleX_fleur = Math.max(0.01, width / 100);
          const adjustedCenterOffsetY_fleur = svgHandEnd_fleur;
          handSvgString = `<g transform="scale(${scaleX_fleur}, ${scaleY_fleur}) translate(${-svgCenterX_fleur}, ${-adjustedCenterOffsetY_fleur})">
            <path d="m 301.83,506.08 c -7.22,19.27 -24.08,34.32 -49.97,26.49 0,0 7.83,-16.25 0.6,-21.07 -7.22,-4.82 -14.45,-7.83 -17.46,-14.45 -1.4,-3.08 -5.28,-3.94 -9.03,-3.98 -3.75,0.04 -7.63,0.9 -9.03,3.98 -3.01,6.62 -10.23,9.63 -17.46,14.45 -7.23,4.82 0.6,21.07 0.6,21.07 -25.89,7.83 -42.74,-7.22 -49.97,-26.49 -7.22,-19.27 14.45,-33.71 14.45,-33.71 4.82,21.67 27.69,12.04 27.69,12.04 11.44,10.84 28.9,-8.43 24.38,-12.04 -4.51,-3.61 -3.31,-13.85 -3.31,-13.85 10.23,-14.45 -14.45,-24.08 -14.45,-24.08 8.35,-13.79 19.52,-17.06 27.09,-17.5 7.57,0.44 18.74,3.7 27.09,17.5 0,0 -24.68,9.63 -14.45,24.08 0,0 1.2,10.23 -3.31,13.85 -4.52,3.61 12.94,22.88 24.38,12.04 0,0 22.88,9.63 27.69,-12.04 0,0 21.67,14.45 14.45,33.71 z m -75.86,62.46 c -9.16,-11.62 -25.29,-25.13 -25.29,-25.13 5.03,-2.51 17.9,-14.92 25.29,-22.24 7.38,7.33 20.26,19.73 25.29,22.24 0,0 -16.12,13.52 -25.29,25.13 z m 24.94,399.3 c 0,13.77 -11.17,24.94 -24.94,24.94 -13.77,0 -24.94,-11.17 -24.94,-24.94 0,-13.77 11.17,-24.94 24.94,-24.94 13.77,0 24.94,11.17 24.94,24.94 z m 34.66,-512.33 c -11.44,-1.2 -15.05,-0.6 -15.65,-16.86 -0.6,-16.26 -27.69,-28.9 -31.91,-34.92 -4.21,-6.02 6.02,-137.87 6.02,-166.76 0,-40.98 -18.06,-68.63 -18.06,-68.63 0,0 -18.06,27.65 -18.06,68.63 0,28.9 10.23,160.74 6.02,166.76 -4.21,6.02 -31.31,18.66 -31.91,34.92 -0.6,16.25 -4.21,15.65 -15.65,16.86 -11.44,1.2 -33.71,20.47 -28.3,48.16 5.42,27.69 23.48,35.52 34.32,37.33 0,0 1.81,24.68 18.06,23.48 16.25,-1.2 23.48,3.01 25.89,13.85 2.41,10.84 -5.42,4.21 -12.64,6.02 -7.22,1.81 -5.42,15.05 4.82,15.05 10.23,0 10.23,13.85 3.61,43.35 -6.62,29.5 -17.46,153.52 3.01,198.67 2.41,7.22 -28.29,4.21 -24.68,25.89 1.81,4.82 16.86,-6.62 22.88,1.81 6.02,8.43 -4.82,14.45 -7.83,19.27 -2.43,3.89 5.76,14.48 8.67,24.12 -25.59,5.43 -44.79,28.14 -44.79,55.35 0,27.3 19.33,50.08 45.04,55.41 -2.63,4.21 -7.04,5.73 -6.86,10.82 0.25,7.22 11.79,10.23 5.77,21.07 -6.02,10.84 -23.48,0 -23.48,0 -5.42,20.47 22.28,30.1 22.28,30.1 -0.6,31.91 13.85,36.73 13.85,36.73 0,0 14.45,-4.82 13.85,-36.73 0,0 27.69,-9.63 22.28,-30.1 0,0 -17.46,10.84 -23.48,0 -6.02,-10.84 5.52,-13.85 5.77,-21.07 0.18,-5.08 -4.23,-6.6 -6.86,-10.82 25.71,-5.33 45.04,-28.11 45.04,-55.41 0,-27.21 -19.2,-49.92 -44.79,-55.35 2.91,-9.64 11.1,-20.22 8.67,-24.12 -3.01,-4.82 -13.85,-10.84 -7.83,-19.27 6.02,-8.43 21.07,3.01 22.88,-1.81 3.61,-21.67 -27.09,-18.66 -24.68,-25.89 20.47,-45.15 9.63,-169.17 3.01,-198.67 -6.62,-29.5 -6.62,-43.35 3.61,-43.35 10.23,0 12.04,-13.24 4.82,-15.05 -7.22,-1.81 -15.05,4.82 -12.64,-6.02 2.41,-10.84 9.63,-15.05 25.89,-13.85 16.25,1.2 18.06,-23.48 18.06,-23.48 10.84,-1.81 28.9,-9.63 34.32,-37.33 5.42,-27.69 -16.86,-46.96 -28.3,-48.16" fill="${color}" />
          </g>`;
          break;
        default:
          handSvgString = `<line x1="0" y1="${tailLength}" x2="0" y2="${-length}" stroke="${color}" stroke-width="${width}" stroke-linecap="round"/>`;
          break;
      }
      return `<g transform="${transform}">${handSvgString}</g>`;
    }

    function generateNumbers() {
      if (settings.numberPattern === "none") return "";
      const roman = ["XII", "I", "II", "III", "IIII", "V", "VI", "VII", "VIII", "IX", "X", "XI"];
      const kanji = ["十二", "一", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一"];
      const zodiac = ["子", "丑", "寅", "卯", "辰", "巳", "午", "未", "申", "酉", "戌", "亥"];
      let html = "";
      for (let i = 0; i < 12; i++) {
        const angle = i * 30;
        const x = 50 + safeNumber(settings.numberPosition, 35) * Math.sin((angle * Math.PI) / 180);
        const y = 50 - safeNumber(settings.numberPosition, 35) * Math.cos((angle * Math.PI) / 180);
        let content;
        const fontStyle = settings.numberItalic ? "italic" : "normal";
        const fontWeight = settings.numberBold ? "bold" : "normal";
        const transform = settings.numberOrientation === "radial" ? `transform="rotate(${angle} ${x} ${y})"` : "";
        switch (settings.numberPattern) {
          case "roman": content = roman[i]; break;
          case "arabic": content = (i === 0 ? 12 : i); break;
          case "kanji": content = kanji[i]; break;
          case "zodiac": content = zodiac[i]; break;
          case "dots": html += `<circle cx="${x}" cy="${y}" r="${safeNumber(settings.fontSize, 4) / 3}" fill="${settings.numberColor}" />`; continue;
          case "bars": const bw = safeNumber(settings.fontSize,4)/4, bh = safeNumber(settings.fontSize,4)*1.2, rx=x-bw/2, ry=y-bh/2; html += `<rect x="${rx}" y="${ry}" width="${bw}" height="${bh}" fill="${settings.numberColor}" transform="rotate(${angle} ${x} ${y})" />`; continue;
          default: content = (i === 0 ? 12 : i);
        }
        html += `<text class="number" x="${x}" y="${y}" ${transform} text-anchor="middle" dominant-baseline="central" style="font-style: ${fontStyle}; font-weight: ${fontWeight};">${content}</text>`;
      }
      return html;
    }

    function generateTicks() {
      let html = "";
      for (let i = 0; i < 60; i++) {
        const angle = i * 6;
        const isMajor = i % 5 === 0;
        const tl = isMajor ? safeNumber(settings.majorTickLength,5) : safeNumber(settings.minorTickLength,2);
        const tw = isMajor ? safeNumber(settings.majorTickWidth,1) : safeNumber(settings.majorTickWidth,1)/2;
        const tp = safeNumber(settings.tickPosition,42);
        const ox = 50 + tp * Math.sin((angle * Math.PI)/180);
        const oy = 50 - tp * Math.cos((angle * Math.PI)/180);
        const ix = 50 + (tp - tl) * Math.sin((angle * Math.PI)/180);
        const iy = 50 - (tp - tl) * Math.cos((angle * Math.PI)/180);
        html += `<line class="tick" x1="${ox}" y1="${oy}" x2="${ix}" y2="${iy}" stroke-width="${tw}" />`;
      }
      return html;
    }

    function updateClock() {
      const now = new Date();
      const tzOffset = getTimezoneOffset(settings.timezone) + now.getTimezoneOffset();
      const adjDate = new Date(now.getTime() + tzOffset * 60000);
      const h = adjDate.getHours()%12, m = adjDate.getMinutes(), s = adjDate.getSeconds(), ms = adjDate.getMilliseconds();
      const hDeg = 30*(h+m/60), mDeg = 6*(m+s/60), sDeg = 6*(s+(settings.smoothSecond?ms/1000:0));

      document.getElementById("hour").innerHTML = drawHand("hour", hDeg, safeNumber(settings.hourHandLength,25), safeNumber(settings.hourHandWidth,2), settings.hourHandColor, settings.hourHandShape, safeNumber(settings.hourHandTailLength,5), safeNumber(settings.hourHandPivotOffsetY,0));
      document.getElementById("minute").innerHTML = drawHand("minute", mDeg, safeNumber(settings.minuteHandLength,35), safeNumber(settings.minuteHandWidth,1.5), settings.minuteHandColor, settings.minuteHandShape, safeNumber(settings.minuteHandTailLength,5), safeNumber(settings.minuteHandPivotOffsetY,0));
      document.getElementById("second").innerHTML = drawHand("second", sDeg, safeNumber(settings.secondHandLength,40), safeNumber(settings.secondHandWidth,0.5), settings.secondHandColor, settings.secondHandShape, safeNumber(settings.secondHandTailLength,10), safeNumber(settings.secondHandPivotOffsetY,0));

      if(settings.showDate) document.getElementById("date-text").textContent = `${adjDate.getMonth()+1}/${adjDate.getDate()}`;
      if(settings.showDay) document.getElementById("day-text").textContent = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"][adjDate.getDay()];
      requestAnimationFrame(updateClock);
    }

    document.addEventListener('DOMContentLoaded', async function() {
      // defs要素はHTML生成時に既に含まれているため、ここでは更新しない
      // const defs = document.querySelector('defs');
      // defs.innerHTML = `${getCustomGradient(settings.faceColor,"faceGradient",settings.faceMaterial)}${getCustomGradient(settings.borderColor,"borderGradient",settings.borderMaterial)}${getCustomGradient(settings.innerBorderColor,"innerBorderGradient",settings.innerBorderMaterial)}`;
      if(settings.showNumbers) document.getElementById('numbers').innerHTML = generateNumbers();
      if(settings.showTicks) document.getElementById('ticks').innerHTML = generateTicks();
      if (settings.weather.enabled && settings.weather.city) {
        weatherData = await fetchWeatherData(); updateWeatherDisplay();
        setInterval(async () => { weatherData = await fetchWeatherData(); updateWeatherDisplay(); }, (settings.weather.updateInterval||30)*60*1000);
      }
      updateClock();
    });
  </script>
</body>
</html>
